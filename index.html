<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤œå¸‚å½ˆç å° V8 (æ··æ²Œç‰©ç†ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <style>
        :root {
            --bg-dark: #121218;
            --panel-bg: #1e1e24;
            --neon-blue: #00f2ff;
            --neon-pink: #ff0055;
            --neon-gold: #ffcc00;
            --text-main: #ffffff;
            --text-sub: #888888;
        }

        body {
            background-color: var(--bg-dark);
            color: var(--text-main);
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
        }

        /* é ‚éƒ¨å°èˆª */
        .top-bar {
            width: 100%; max-width: 480px;
            display: flex; justify-content: flex-end; gap: 10px;
            margin-bottom: 15px;
        }
        .nav-btn {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: white; padding: 5px 12px; border-radius: 15px; cursor: pointer;
            font-size: 0.85em; transition: 0.2s;
        }
        .nav-btn:hover { background: rgba(255,255,255,0.2); }

        h1 {
            color: var(--neon-pink);
            text-shadow: 0 0 10px var(--neon-pink);
            margin: 0 0 15px 0;
            font-style: italic; letter-spacing: 2px;
        }

        /* æ©Ÿå°å¤–æ¡† */
        .machine {
            position: relative;
            background: #2a2a35;
            padding: 15px;
            border-radius: 20px;
            border: 4px solid #444;
            box-shadow: 0 0 40px rgba(0,0,0,0.6);
            max-width: 450px; width: 100%;
            display: flex; flex-direction: column; align-items: center;
        }

        /* è³‡è¨Šå„€è¡¨æ¿ */
        .dashboard {
            width: 100%;
            display: flex; justify-content: space-between;
            background: #111; padding: 10px; border-radius: 10px;
            margin-bottom: 15px; box-sizing: border-box;
            border: 1px solid #333;
        }
        .dash-item { display: flex; flex-direction: column; }
        .dash-label { font-size: 0.75em; color: var(--text-sub); }
        .dash-val { font-size: 1.1em; font-weight: bold; color: var(--neon-blue); font-family: monospace; }
        #poolAmount { color: var(--neon-gold); }

        /* éŠæˆ²ç•«å¸ƒ */
        canvas {
            background: #1a150e; /* æ·±æœ¨è‰²èƒŒæ™¯ */
            border-radius: 12px;
            border: 2px solid #5c3a1b;
            box-shadow: inset 0 0 50px rgba(0,0,0,0.8);
            margin-bottom: 15px;
            cursor: pointer;
        }

        /* æ§åˆ¶å€ */
        .controls { width: 100%; display: flex; flex-direction: column; gap: 10px; }

        .btn {
            padding: 14px; border: none; border-radius: 10px;
            font-weight: bold; font-size: 1rem; cursor: pointer;
            text-transform: uppercase; transition: 0.2s; position: relative; overflow: hidden;
        }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        .btn:active { transform: scale(0.98); }

        .btn-connect { background: #3b82f6; color: white; }
        .btn-random { background: linear-gradient(135deg, #e11d48, #be123c); color: white; box-shadow: 0 4px 10px rgba(225, 29, 72, 0.3); }
        .btn-play { background: linear-gradient(135deg, #00f260, #0575e6); color: white; box-shadow: 0 4px 10px rgba(5, 117, 230, 0.3); }

        .input-wrapper {
            display: flex; justify-content: space-between; align-items: center;
            background: #111; padding: 8px 15px; border-radius: 10px; border: 1px solid #333;
        }
        .bet-input {
            background: transparent; border: none; color: white; font-size: 1.2rem;
            text-align: right; width: 80px; font-weight: bold;
        }
        .bet-input:focus { outline: none; }

        .wallet-info {
            font-size: 0.85em; color: var(--text-sub); margin-top: 5px;
            display: flex; justify-content: space-between; width: 100%;
        }

        /* å½ˆçª— */
        .modal-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(4px);
            display: none; justify-content: center; align-items: center; z-index: 1000;
        }
        .modal-content {
            background: var(--panel-bg); padding: 30px; border-radius: 15px;
            text-align: center; border: 1px solid #444; width: 85%; max-width: 350px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.8);
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        @keyframes popIn { from{transform: scale(0.8); opacity:0;} to{transform: scale(1); opacity:1;} }

        .rule-row { text-align: left; margin-bottom: 12px; border-bottom: 1px solid #333; padding-bottom: 8px; font-size: 0.9em; line-height: 1.4; }
        .rule-title { color: var(--neon-gold); font-weight: bold; margin-bottom: 4px; }
    </style>
</head>
<body>

<div class="top-bar">
    <button class="nav-btn" onclick="openRules()"><span data-i18n="rules">è¦å‰‡èªªæ˜</span></button>
    <button class="nav-btn" onclick="toggleLang()">EN / ä¸­æ–‡</button>
</div>

<h1><span data-i18n="title">å¤œå¸‚å½ˆç å°</span> <span style="font-size:0.5em; color:#555;">V8</span></h1>

<div class="machine">
    <div class="dashboard">
        <div class="dash-item">
            <span class="dash-label" data-i18n="multiplier">ç•¶å‰å€ç‡</span>
            <span class="dash-val" id="disp-multi" style="color:var(--neon-pink)">--</span>
        </div>
        <div class="dash-item" style="text-align:right;">
            <span class="dash-label" data-i18n="pool">ç¸½çæ± </span>
            <span class="dash-val" id="poolAmount">--</span>
        </div>
    </div>

    <canvas id="gameCanvas" width="400" height="580"></canvas>

    <div class="controls">
        <button class="btn btn-connect" id="connectBtn" onclick="connectWallet()"><span data-i18n="connect">é€£æ¥éŒ¢åŒ…</span></button>
        
        <div id="gameUI" style="display:none; width:100%; flex-direction:column; gap:10px;">
            <div class="wallet-info">
                <span id="walletAddr">--</span>
                <span><span data-i18n="balance">é¤˜é¡</span>: <span id="userBalance" style="color:var(--neon-blue)">--</span> CRO</span>
            </div>

            <button class="btn btn-random" id="randomBtn" onclick="randomizeConfig()"><span data-i18n="random_btn">ğŸ° æŠ•å¹£é¸å° (éš¨æ©Ÿé…ç½®)</span></button>
            
            <div class="input-wrapper">
                <span style="color:#aaa; font-size:0.9em;" data-i18n="bet">ä¸‹æ³¨é‡‘é¡</span>
                <div>
                    <input type="number" id="betAmount" value="1" class="bet-input" oninput="validateBet()">
                    <span style="color:var(--neon-blue); font-weight:bold;">CRO</span>
                </div>
            </div>

            <button class="btn btn-play" id="playBtn" onclick="playGame()" disabled><span data-i18n="play_btn">ğŸ”´ æ‹‰æ¡¿ç™¼å°„</span></button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="rulesModal">
    <div class="modal-content">
        <h2 style="color:var(--neon-gold); margin-top:0;" data-i18n="rules_title">ğŸ“œ éŠæˆ²è¦å‰‡</h2>
        <div id="rulesContent" style="margin:20px 0; max-height:300px; overflow-y:auto;">
            </div>
        <button class="btn" style="background:#333; color:white; width:100%; padding:10px;" onclick="closeModal('rulesModal')"><span data-i18n="close">é—œé–‰</span></button>
    </div>
</div>

<div class="modal-overlay" id="resultModal">
    <div class="modal-content">
        <h2 id="resTitle">WIN!</h2>
        <div id="resVal" style="font-size:2.5em; color:#0f0; margin:20px 0; font-weight:800; text-shadow:0 0 15px rgba(0,255,0,0.5);">+10 CRO</div>
        <button class="btn" style="background:#333; color:white; width:100%;" onclick="closeModal('resultModal')"><span data-i18n="confirm">ç¢ºå®š</span></button>
    </div>
</div>

<script>
    const CONTRACT_ADDRESS = "0xF7A250Da8B321ce557d0fF415BA93894650A5E12";
    const ABI = [
        "function play(uint256 chosenMultiplier) external payable",
        "function getBankrollBalance() external view returns (uint256)",
        "event BallShot(address indexed player, uint256 betAmount, uint256 multiplier, uint256 payout)"
    ];

    // --- å¤šèªè¨€è¨­å®š ---
    const i18n = {
        zh: {
            title: "å¤œå¸‚å½ˆç å°", rules: "è¦å‰‡èªªæ˜", connect: "é€£æ¥éŒ¢åŒ…", multiplier: "ç•¶å‰å€ç‡", pool: "ç¸½çæ± ",
            balance: "é¤˜é¡", random_btn: "ğŸ° æŠ•å¹£é¸å° (éš¨æ©Ÿé…ç½®)", bet: "ä¸‹æ³¨", play_btn: "ğŸ”´ æ‹‰æ¡¿ç™¼å°„",
            rules_title: "ğŸ“œ éŠæˆ²è¦å‰‡", close: "é—œé–‰", confirm: "ç¢ºå®š",
            win: "ğŸ‰ ä¸­çå•¦ï¼", lose: "ğŸ˜¢ æ²’ä¸­...", waiting: "ç¢ºèªä¸­...", rolling: "å½ˆç æ»¾å‹•ä¸­...",
            rule_html: `
                <div class="rule-row"><div class="rule-title">1. é¸å°</div>é»æ“Šã€ŒæŠ•å¹£é¸å°ã€éš¨æ©Ÿåˆ‡æ›å€ç‡ (2X~10X) èˆ‡äº®ç‡ˆé…ç½®ã€‚</div>
                <div class="rule-row"><div class="rule-title">2. äº®ç‡ˆæ©Ÿåˆ¶</div>å€ç‡è¶Šé«˜ï¼Œäº®ç‡ˆæ•¸è¶Šå°‘ (ä¾‹å¦‚ 10å€ åªäº® 1 ç‡ˆ)ã€‚</div>
                <div class="rule-row"><div class="rule-title">3. ç²å‹</div>å½ˆç è½å…¥ã€Œäº®ç‡ˆã€æ´å£å³ç²å‹ï¼›è½å…¥æ»…ç‡ˆæ´å£å‰‡å¤±æ•—ã€‚</div>
                <div class="rule-row"><div class="rule-title">4. ç‰©ç†</div>æ¨¡æ“¬çœŸå¯¦ç‰©ç†ï¼Œå½ˆç è»Œè·¡éš¨æ©Ÿï¼Œå°å¿ƒé‡˜å­ï¼</div>
            `
        },
        en: {
            title: "Pinball", rules: "Rules", connect: "Connect Wallet", multiplier: "Multiplier", pool: "Pool",
            balance: "Balance", random_btn: "ğŸ° Random Setup", bet: "Bet", play_btn: "ğŸ”´ Launch Ball",
            rules_title: "ğŸ“œ Game Rules", close: "Close", confirm: "OK",
            win: "ğŸ‰ YOU WIN!", lose: "ğŸ˜¢ MISSED...", waiting: "Confirming...", rolling: "Rolling...",
            rule_html: `
                <div class="rule-row"><div class="rule-title">1. Setup</div>Click 'Random Setup' to get a multiplier (2X~10X) and lit slots.</div>
                <div class="rule-row"><div class="rule-title">2. Lights</div>Higher multiplier = fewer lit slots (e.g., 10X has 1 light).</div>
                <div class="rule-row"><div class="rule-title">3. Win</div>Land in a LIT slot to win. Unlit slots lose.</div>
                <div class="rule-row"><div class="rule-title">4. Physics</div>Real physics simulation. Watch out for the pins!</div>
            `
        }
    };
    let curLang = 'zh';

    // --- éŠæˆ²è®Šæ•¸ ---
    const CONFIGS = [
        { multi: 2, lights: 4 },
        { multi: 4, lights: 3 },
        { multi: 6, lights: 2 },
        { multi: 8, lights: 2 },
        { multi: 10, lights: 1 }
    ];
    const NUM_SLOTS = 10;
    
    // --- ç‰©ç†å¼•æ“è®Šæ•¸ (V8 æ··æ²Œç‰ˆ) ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const width = canvas.width;
    const height = canvas.height;

    const GRAVITY = 0.18;       // é‡åŠ›
    const BOUNCE = 0.5;         // å½ˆåŠ›
    const FRICTION = 0.99;      // ç©ºæ°£é˜»åŠ›
    const PIN_RADIUS = 3;
    const BALL_RADIUS = 7;

    let ball = { x: 0, y: 0, vx: 0, vy: 0, active: false };
    let pins = [];
    let slots = [];
    let activeSlotIndices = [];
    let targetSlotIndex = -1;
    let pinHitIndex = -1; // ç”¨æ–¼è¦–è¦ºå›é¥‹

    // åˆå§‹åŒ–ç‰©ç†å ´æ™¯ (äº¤éŒ¯æ’åˆ— + éš¨æ©Ÿæ“¾å‹•)
    function initPhysics() {
        pins = [];
        const rows = 11; 
        const startY = 90;
        const spacingY = 40;

        for (let r = 0; r < rows; r++) {
            // äº¤éŒ¯æ’åˆ—ï¼šå¶æ•¸è¡Œå°‘ä¸€å€‹é‡˜å­ï¼Œä¸”æ•´é«”å‘å³åç§»
            const isEven = r % 2 === 0;
            const cols = isEven ? 8 : 9;
            const rowWidth = (cols - 1) * 40;
            const offsetX = (width - rowWidth) / 2;

            for (let c = 0; c < cols; c++) {
                // åŠ å…¥éš¨æ©Ÿæ“¾å‹• (Jitter)ï¼Œè®“é‡˜å­æ­ªæ­ªçš„
                const jitterX = (Math.random() - 0.5) * 6; 
                const jitterY = (Math.random() - 0.5) * 6;
                
                pins.push({
                    x: offsetX + c * 40 + jitterX,
                    y: startY + r * spacingY + jitterY
                });
            }
        }

        // åº•éƒ¨æ´å£
        const slotWidth = width / NUM_SLOTS;
        slots = [];
        for(let i=0; i<NUM_SLOTS; i++) {
            slots.push({
                x: i * slotWidth,
                w: slotWidth,
                cx: i * slotWidth + slotWidth / 2,
            });
        }
    }

    // ç¹ªåœ–å¾ªç’°
    function draw() {
        // æ¸…é™¤èƒŒæ™¯
        ctx.fillStyle = '#1a150e';
        ctx.fillRect(0, 0, width, height);

        // 1. ç•«é‡˜å­
        pins.forEach((p, i) => {
            ctx.beginPath();
            ctx.arc(p.x, p.y, PIN_RADIUS, 0, Math.PI * 2);
            // æ’åˆ°æ™‚ç™¼äº®
            if (i === pinHitIndex) {
                ctx.fillStyle = '#fff';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#fff';
            } else {
                ctx.fillStyle = '#888';
                ctx.shadowBlur = 0;
            }
            ctx.fill();
        });
        ctx.shadowBlur = 0;
        if(pinHitIndex !== -1) pinHitIndex = -1; // é‡ç½®

        // 2. ç•«æ´å£
        for(let i=0; i<NUM_SLOTS; i++) {
            const s = slots[i];
            const isLit = activeSlotIndices.includes(i);
            
            // æ´å£æœ¬é«”
            ctx.fillStyle = '#111';
            ctx.fillRect(s.x+1, height-40, s.w-2, 40);
            
            // ç‡ˆè™Ÿ
            if(isLit) {
                ctx.fillStyle = '#00f2ff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#00f2ff';
                ctx.beginPath();
                ctx.arc(s.cx, height-25, 5, 0, Math.PI*2);
                ctx.fill();
                ctx.shadowBlur = 0;
            } else {
                ctx.fillStyle = '#333';
                ctx.beginPath();
                ctx.arc(s.cx, height-25, 3, 0, Math.PI*2);
                ctx.fill();
            }
            // åˆ†éš”ç·š
            ctx.strokeStyle = '#444';
            ctx.beginPath();
            ctx.moveTo(s.x, height-40);
            ctx.lineTo(s.x, height);
            ctx.stroke();
        }

        // 3. ç•«çƒ
        if (ball.active) {
            updatePhysics();
            ctx.fillStyle = '#ff0055';
            ctx.shadowBlur = 10; ctx.shadowColor = '#ff0055';
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
            // é«˜å…‰
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(ball.x-2, ball.y-2, 2, 0, Math.PI*2); ctx.fill();
        }

        requestAnimationFrame(draw);
    }

    // ğŸ”¥ ç‰©ç†æ ¸å¿ƒ (é˜²æ²¾é» + å¾®é¢¨å°èˆª)
    function updatePhysics() {
        ball.vy += GRAVITY;
        ball.vx *= FRICTION;
        ball.vy *= FRICTION;
        
        // é åˆ¤ä½ç½®
        let nextX = ball.x + ball.vx;
        let nextY = ball.y + ball.vy;

        // ç‰†å£ç¢°æ’
        if (nextX < BALL_RADIUS) { nextX = BALL_RADIUS; ball.vx *= -0.6; }
        if (nextX > width - BALL_RADIUS) { nextX = width - BALL_RADIUS; ball.vx *= -0.6; }

        // é‡˜å­ç¢°æ’æª¢æ¸¬
        for (let i=0; i<pins.length; i++) {
            const p = pins[i];
            const dx = nextX - p.x;
            const dy = nextY - p.y;
            const distSq = dx*dx + dy*dy;
            const minDist = BALL_RADIUS + PIN_RADIUS;

            if (distSq < minDist * minDist) {
                // ç™¼ç”Ÿç¢°æ’
                pinHitIndex = i;
                const angle = Math.atan2(dy, dx);
                
                // ğŸ”¥ é˜²æ²¾é»é—œéµï¼šå¼·åˆ¶æ¨é–‹åˆ°å®‰å…¨è·é›¢
                const pushOut = 1.0; 
                nextX = p.x + Math.cos(angle) * (minDist + pushOut);
                nextY = p.y + Math.sin(angle) * (minDist + pushOut);

                // åå°„é€Ÿåº¦ + éš¨æ©Ÿæ—‹è½‰é€ æˆçš„æ°´å¹³åˆ†é‡
                const noise = (Math.random() - 0.5) * 1.5; 
                ball.vx += Math.cos(angle) * 1.5 + noise; 
                ball.vy = Math.abs(ball.vy) * -BOUNCE; // Yè»¸åè½‰ä¸¦å¸èƒ½
                
                // ç¢ºä¿ç¢°æ’å¾Œæœ‰è¶³å¤ çš„æ°´å¹³é€Ÿåº¦è„«é›¢ï¼Œé¿å…å‚ç›´å½ˆè·³
                if(Math.abs(ball.vx) < 0.5) ball.vx += (Math.random() > 0.5 ? 1 : -1);
            }
        }

        // å¾®é¢¨å°èˆª (åƒ…åœ¨ä¸‹åŠéƒ¨å•Ÿå‹•)
        if (targetSlotIndex !== -1 && nextY < height - 60) {
            const targetX = slots[targetSlotIndex].cx;
            const dist = targetX - ball.x;
            // éå¸¸å¾®å¼±çš„å´å‘æ¨åŠ›ï¼Œéš¨è‘—é«˜åº¦å¢åŠ 
            const wind = 0.004 + (nextY / height) * 0.01;
            ball.vx += dist * wind;
        }

        ball.x = nextX;
        ball.y = nextY;

        // é€²æ´åˆ¤å®š
        if (ball.y > height - BALL_RADIUS) {
            ball.active = false;
            ball.x = slots[targetSlotIndex].cx;
            ball.y = height - 25;
            setTimeout(showResult, 200);
        }
    }

    // --- Web3 èˆ‡ é‚è¼¯ ---
    let provider, signer, contract, userAddress;
    let currentConfig = null;
    let pendingResult = null;
    let pollInterval;

    async function connectWallet() {
        if (!window.ethereum) return alert("Please install MetaMask");
        try {
            provider = new ethers.BrowserProvider(window.ethereum);
            signer = await provider.getSigner();
            userAddress = await signer.getAddress();
            
            document.getElementById("connectBtn").style.display = "none";
            document.getElementById("gameUI").style.display = "flex";
            document.getElementById("walletAddr").innerText = userAddress.substring(0,6) + "...";

            contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer);
            
            await updateData();
            randomizeConfig();
            initPhysics();
            draw();
            
            // å•Ÿå‹•è‡ªå‹•æ›´æ–° (æ¯5ç§’)
            pollInterval = setInterval(updateData, 5000);

        } catch (e) { alert("Connect Failed"); }
    }

    // æ•´åˆæ›´æ–° (é¤˜é¡ + çæ± )
    async function updateData() {
        if(!contract || !userAddress) return;
        try {
            // æŸ¥çæ± 
            const bal = await contract.getBankrollBalance();
            document.getElementById("poolAmount").innerText = parseFloat(ethers.formatEther(bal)).toFixed(2) + " CRO";
            
            // æŸ¥ç©å®¶é¤˜é¡
            const userBal = await provider.getBalance(userAddress);
            document.getElementById("userBalance").innerText = parseFloat(ethers.formatEther(userBal)).toFixed(2);
        } catch(e){}
    }

    function randomizeConfig() {
        const conf = CONFIGS[Math.floor(Math.random() * CONFIGS.length)];
        currentConfig = conf;
        
        document.getElementById("disp-multi").innerText = conf.multi + "X";
        document.getElementById("disp-multi").style.color = getMultiColor(conf.multi);

        let all = Array.from({length: NUM_SLOTS}, (_, i) => i);
        activeSlotIndices = all.sort(() => 0.5 - Math.random()).slice(0, conf.lights);
        validateBet(); // é‡ç½®æŒ‰éˆ•ç‹€æ…‹
    }

    function getMultiColor(m) {
        if(m==10) return '#ff0055';
        if(m==8) return '#ffaa00';
        return '#00f2ff';
    }

    function validateBet() {
        const amt = document.getElementById("betAmount").value;
        const btn = document.getElementById("playBtn");
        if(amt > 0 && currentConfig) {
            btn.disabled = false;
        } else {
            btn.disabled = true;
        }
    }

    async function playGame() {
        if (!currentConfig) return;
        const amt = document.getElementById("betAmount").value;
        const playBtn = document.getElementById("playBtn");
        
        playBtn.disabled = true;
        playBtn.innerHTML = getTrans("waiting");

        try {
            const tx = await contract.play(currentConfig.multi, { value: ethers.parseEther(amt) });
            playBtn.innerHTML = getTrans("rolling");
            
            const receipt = await tx.wait();
            
            let wonMultiplier = 0;
            let payout = 0;
            for (const log of receipt.logs) {
                try {
                    const parsed = contract.interface.parseLog(log);
                    if (parsed.name === "BallShot" && parsed.args.player === userAddress) {
                        wonMultiplier = Number(parsed.args.multiplier);
                        payout = ethers.formatEther(parsed.args.payout);
                    }
                } catch(e){}
            }
            startBallDrop(wonMultiplier, payout);
            updateData(); // æ‰£æ¬¾å¾Œç«‹å³æ›´æ–°é¤˜é¡

        } catch (e) {
            console.error(e);
            alert("Transaction Cancelled");
            resetUI();
        }
    }

    function startBallDrop(multiplier, payout) {
        pendingResult = { payout, win: multiplier > 0 };
        
        if (multiplier > 0) {
            targetSlotIndex = activeSlotIndices[Math.floor(Math.random() * activeSlotIndices.length)];
        } else {
            let all = Array.from({length: NUM_SLOTS}, (_, i) => i);
            let empty = all.filter(i => !activeSlotIndices.includes(i));
            targetSlotIndex = empty[Math.floor(Math.random() * empty.length)];
        }

        // ç™¼å°„ä½ç½®éš¨æ©ŸåŒ–
        ball.x = width / 2 + (Math.random()-0.5)*40; 
        ball.y = 20;
        ball.vx = (Math.random() - 0.5) * 4; 
        ball.vy = 0;
        ball.active = true;
    }

    function showResult() {
        const modal = document.getElementById("resultModal");
        const title = document.getElementById("resTitle");
        const val = document.getElementById("resVal");
        
        modal.style.display = "flex";
        if (pendingResult.win) {
            title.innerText = getTrans("win");
            title.style.color = "#00f2ff";
            val.innerText = "+" + pendingResult.payout + " CRO";
        } else {
            title.innerText = getTrans("lose");
            title.style.color = "#888";
            val.innerText = "Try Again";
        }
        updateData();
    }

    function resetUI() {
        const btn = document.getElementById("playBtn");
        btn.disabled = false;
        btn.innerHTML = `<span data-i18n="play_btn">${getTrans("play_btn")}</span>`;
    }

    // --- UI è¼”åŠ© ---
    function openRules() {
        document.getElementById("rulesModal").style.display = "flex";
        updateText();
    }
    function closeModal(id) {
        document.getElementById(id).style.display = "none";
        if(id === "resultModal") resetUI();
    }
    function toggleLang() {
        curLang = curLang === 'zh' ? 'en' : 'zh';
        updateText();
    }
    function getTrans(key) { return i18n[curLang][key]; }
    function updateText() {
        document.querySelectorAll('[data-i18n]').forEach(el => {
            el.innerText = i18n[curLang][el.getAttribute('data-i18n')];
        });
        document.getElementById("rulesContent").innerHTML = i18n[curLang]['rule_html'];
    }

    // åˆå§‹åŸ·è¡Œ
    updateText();
    initPhysics();
    draw(); // å•Ÿå‹•èƒŒæ™¯æ¸²æŸ“
</script>

</body>
</html>



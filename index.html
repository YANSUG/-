<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cronos å¤œå¸‚å½ˆç å° (ä¸»ç¶²æ­£å¼ç‰ˆ)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <style>
        :root { --bg-dark: #0f0f13; --neon-blue: #00f2ff; --neon-pink: #ff0055; --neon-green: #00ff99; --wood-dark: #1a150e; }
        body { background-color: var(--bg-dark); color: white; font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif; display: flex; flex-direction: column; align-items: center; margin: 0; padding: 15px; min-height: 100vh; }
        .top-bar { width: 100%; max-width: 450px; display: flex; justify-content: flex-end; gap: 10px; margin-bottom: 10px; }
        .nav-btn { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 5px 12px; border-radius: 15px; cursor: pointer; font-size: 0.8em; transition: 0.2s; }
        h1 { color: var(--neon-pink); text-shadow: 0 0 10px var(--neon-pink); margin: 0 0 10px 0; font-style: italic; letter-spacing: 1px; }
        .machine { background: #2a2a35; padding: 15px; border-radius: 20px; border: 4px solid #444; box-shadow: 0 0 40px rgba(0,0,0,0.6); max-width: 450px; width: 100%; display: flex; flex-direction: column; align-items: center; }
        .dashboard { width: 100%; display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 5px; background: #111; padding: 8px 10px; border-radius: 10px; margin-bottom: 10px; box-sizing: border-box; border: 1px solid #333; }
        .dash-item { display: flex; flex-direction: column; align-items: center; }
        .dash-label { font-size: 0.75em; color: #888; margin-bottom: 2px; }
        .dash-val { font-size: 1.1em; font-weight: bold; color: var(--neon-blue); font-family: monospace; }
        canvas { background: var(--wood-dark); border-radius: 12px; border: 2px solid #5c3a1b; box-shadow: inset 0 0 60px rgba(0,0,0,0.9); margin-bottom: 15px; cursor: pointer; background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.02) 0px, rgba(255,255,255,0.02) 2px, transparent 2px, transparent 10px); }
        .controls { width: 100%; display: flex; flex-direction: column; gap: 8px; }
        .btn { padding: 12px; border: none; border-radius: 10px; font-weight: bold; font-size: 1rem; cursor: pointer; text-transform: uppercase; transition: 0.2s; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1); }
        .btn:active { transform: scale(0.98); }
        .btn-connect { background: #3b82f6; color: white; }
        .btn-random { background: linear-gradient(135deg, #e11d48, #be123c); color: white; }
        .btn-play { background: linear-gradient(135deg, #00f260, #0575e6); color: white; box-shadow: 0 4px 10px rgba(5, 117, 230, 0.3); }
        .input-wrapper { display: flex; justify-content: space-between; align-items: center; background: #111; padding: 8px 15px; border-radius: 10px; border: 1px solid #333; transition: 0.3s; }
        .input-wrapper.error { border-color: #ff0055; box-shadow: 0 0 10px rgba(255, 0, 85, 0.3); }
        .bet-input { background: transparent; border: none; color: white; font-size: 1.2rem; text-align: right; width: 80px; font-weight: bold; }
        .bet-input:focus { outline: none; }
        .wallet-info { font-size: 0.8em; color: #888; margin-top: 5px; display: flex; justify-content: space-between; width: 100%; }
        .modal-overlay { position: fixed; top:0; left:0; width:100%; height:100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(4px); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-content { background: #1e1e24; padding: 30px; border-radius: 15px; text-align: center; border: 1px solid #444; width: 80%; max-width: 300px; box-shadow: 0 10px 40px rgba(0,0,0,0.8); animation: popIn 0.3s; }
        @keyframes popIn { from{transform: scale(0.8); opacity:0;} to{transform: scale(1); opacity:1;} }
        .rule-row { text-align: left; margin-bottom: 10px; border-bottom: 1px solid #333; padding-bottom: 5px; font-size: 0.9em; }
    </style>
</head>
<body>

<div class="top-bar">
    <button class="nav-btn" onclick="openRules()"><span data-i18n="rules">è¦å‰‡</span></button>
    <button class="nav-btn" onclick="toggleLang()">EN / ä¸­æ–‡</button>
</div>

<h1><span data-i18n="title">å¤œå¸‚å½ˆç å°</span> <span style="font-size:0.5em; color:#555;">V11</span></h1>

<div class="machine">
    <div class="dashboard">
        <div class="dash-item">
            <span class="dash-label" data-i18n="multiplier">å€ç‡</span>
            <span class="dash-val" id="disp-multi" style="color:var(--neon-pink)">--</span>
        </div>
        <div class="dash-item">
            <span class="dash-label" data-i18n="max_bet">æœ€å¤§ä¸‹æ³¨</span>
            <span class="dash-val" id="maxBetVal" style="color:var(--neon-green)">--</span>
        </div>
        <div class="dash-item">
            <span class="dash-label" data-i18n="pool">ç¸½çæ± </span>
            <span class="dash-val" id="poolAmount" style="color:#ffcc00">--</span>
        </div>
    </div>

    <canvas id="gameCanvas" width="400" height="620"></canvas>

    <div class="controls">
        <button class="btn btn-connect" id="connectBtn" onclick="connectWallet()"><span data-i18n="connect">é€£æ¥éŒ¢åŒ… (Cronos)</span></button>
        <div id="gameUI" style="display:none; width:100%; flex-direction:column; gap:8px;">
            <div class="wallet-info">
                <span id="walletAddr">--</span>
                <span><span data-i18n="balance">é¤˜é¡</span>: <span id="userBalance" style="color:#00f2ff">--</span> CRO</span>
            </div>
            <button class="btn btn-random" id="randomBtn" onclick="randomizeConfig()"><span data-i18n="random_btn">ğŸ° æŠ•å¹£é¸å°</span></button>
            <div class="input-wrapper" id="betWrapper">
                <span style="color:#aaa; font-size:0.9em;" data-i18n="bet">ä¸‹æ³¨</span>
                <div>
                    <input type="number" id="betAmount" value="1" class="bet-input" oninput="validateBet()">
                    <span style="color:#00f2ff; font-weight:bold;">CRO</span>
                </div>
            </div>
            <button class="btn btn-play" id="playBtn" onclick="playGame()" disabled><span data-i18n="play_btn">ğŸ”´ æ‹‰æ¡¿ç™¼å°„</span></button>
        </div>
    </div>
</div>

<div class="modal-overlay" id="rulesModal">
    <div class="modal-content">
        <h3 style="color:#ffcc00; margin-top:0;" data-i18n="rules_title">ğŸ“œ è¦å‰‡</h3>
        <div id="rulesContent" style="margin:20px 0; max-height:300px; overflow-y:auto;"></div>
        <button class="btn" style="background:#333; color:white; padding:8px;" onclick="closeModal('rulesModal')"><span data-i18n="close">é—œé–‰</span></button>
    </div>
</div>

<div class="modal-overlay" id="resultModal">
    <div class="modal-content">
        <h2 id="resTitle">WIN!</h2>
        <div id="resVal" style="font-size:2em; color:#0f0; margin:20px 0;">+10 CRO</div>
        <button class="btn" style="background:#333; color:white; width:100%;" onclick="closeModal('resultModal')"><span data-i18n="confirm">ç¢ºå®š</span></button>
    </div>
</div>

<script>
    // ğŸ”¥ ä¸»ç¶²å½ˆç å°åˆç´„åœ°å€
    const CONTRACT_ADDRESS = "0xbE9A101a6426645d2bF0Ad7BF0cba5073315E945";
    
    const ABI = [
        "function play(uint256 chosenMultiplier) external payable",
        "function getBankrollBalance() external view returns (uint256)",
        "event BallShot(address indexed player, uint256 betAmount, uint256 multiplier, uint256 payout)"
    ];

    const i18n = {
        zh: {
            title: "å¤œå¸‚å½ˆç å°", rules: "è¦å‰‡", connect: "é€£æ¥éŒ¢åŒ… (Cronos)", multiplier: "å€ç‡", pool: "çæ± ", max_bet: "æœ€å¤§ä¸‹æ³¨",
            balance: "é¤˜é¡", random_btn: "ğŸ° æŠ•å¹£é¸å° (éš¨æ©Ÿé…ç½®)", bet: "ä¸‹æ³¨", play_btn: "ğŸ”´ æ‹‰æ¡¿ç™¼å°„",
            rules_title: "ğŸ“œ éŠæˆ²è¦å‰‡", close: "é—œé–‰", confirm: "ç¢ºå®š",
            win: "ğŸ‰ ä¸­çå•¦ï¼", lose: "ğŸ˜¢ æ²’ä¸­...", waiting: "ç¢ºèªä¸­...", rolling: "å½ˆç æ»¾å‹•ä¸­...",
            rule_html: `<div class="rule-row">1. é»æ“Šã€ŒæŠ•å¹£é¸å°ã€éš¨æ©Ÿåˆ‡æ›å€ç‡ã€‚</div><div class="rule-row">2. å€ç‡è¶Šé«˜ï¼Œæœ€å¤§å¯ä¸‹æ³¨é‡‘é¡è¶Šä½ã€‚</div><div class="rule-row">3. å½ˆç è½å…¥ã€Œäº®ç‡ˆã€æ´å£å³ä¸­çã€‚</div>`
        },
        en: {
            title: "Pinball", rules: "Rules", connect: "Connect (Cronos)", multiplier: "Multi", pool: "Pool", max_bet: "Max Bet",
            balance: "Bal", random_btn: "ğŸ° Random Setup", bet: "Bet", play_btn: "ğŸ”´ Launch",
            rules_title: "ğŸ“œ Rules", close: "Close", confirm: "OK",
            win: "ğŸ‰ YOU WIN!", lose: "ğŸ˜¢ MISSED...", waiting: "Confirming...", rolling: "Rolling...",
            rule_html: `<div class="rule-row">1. Click 'Random Setup' to start.</div><div class="rule-row">2. Higher multiplier = Lower Max Bet.</div><div class="rule-row">3. Land in a LIT slot to win.</div>`
        }
    };
    let curLang = 'zh';

    const CONFIGS = [ { multi: 2, lights: 4 }, { multi: 4, lights: 3 }, { multi: 6, lights: 2 }, { multi: 8, lights: 2 }, { multi: 10, lights: 1 } ];
    const NUM_SLOTS = 10;
    const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d');
    const width = canvas.width; const height = canvas.height;
    const GRAVITY = 0.12; const BOUNCE = 0.5; const FRICTION = 0.99; const PIN_RADIUS = 3; const BALL_RADIUS = 6;
    let ball = { x: 0, y: 0, vx: 0, vy: 0, active: false };
    let pins = []; let slots = []; let activeSlotIndices = []; let targetSlotIndex = -1; let pinHitIndex = -1; let mustWin = false;

    function initPhysics() {
        pins = []; const rows = 13; const startY = 80; const spacingY = 35;
        for (let r = 0; r < rows; r++) {
            const isEven = r % 2 === 0; const cols = isEven ? 9 : 10; const rowWidth = (cols - 1) * 38; const offsetX = (width - rowWidth) / 2;
            for (let c = 0; c < cols; c++) { const jitterX = (Math.random() - 0.5) * 8; const jitterY = (Math.random() - 0.5) * 8; pins.push({ x: offsetX + c * 38 + jitterX, y: startY + r * spacingY + jitterY }); }
        }
        const slotWidth = width / NUM_SLOTS; slots = [];
        for(let i=0; i<NUM_SLOTS; i++) { slots.push({ x: i * slotWidth, w: slotWidth, cx: i * slotWidth + slotWidth / 2, }); }
    }

    function draw() {
        ctx.fillStyle = '#1a150e'; ctx.fillRect(0, 0, width, height);
        pins.forEach((p, i) => { ctx.beginPath(); ctx.arc(p.x, p.y, PIN_RADIUS, 0, Math.PI * 2); if (i === pinHitIndex) { ctx.fillStyle = '#fff'; ctx.shadowBlur = 8; ctx.shadowColor = '#fff'; } else { ctx.fillStyle = '#999'; ctx.shadowBlur = 0; } ctx.fill(); }); ctx.shadowBlur = 0; if(pinHitIndex !== -1) pinHitIndex = -1;
        for(let i=0; i<NUM_SLOTS; i++) {
            const s = slots[i]; const isLit = activeSlotIndices.includes(i);
            ctx.fillStyle = '#111'; ctx.fillRect(s.x+1, height-40, s.w-2, 40);
            if(isLit) { ctx.fillStyle = '#00f2ff'; ctx.shadowBlur = 15; ctx.shadowColor = '#00f2ff'; ctx.beginPath(); ctx.arc(s.cx, height-25, 5, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; } 
            else { ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(s.cx, height-25, 3, 0, Math.PI*2); ctx.fill(); }
            ctx.strokeStyle = '#444'; ctx.beginPath(); ctx.moveTo(s.x, height-40); ctx.lineTo(s.x, height); ctx.stroke();
        }
        if (ball.active) { updatePhysics(); ctx.fillStyle = '#ff0055'; ctx.shadowBlur = 10; ctx.shadowColor = '#ff0055'; ctx.beginPath(); ctx.arc(ball.x, ball.y, BALL_RADIUS, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(ball.x-2, ball.y-2, 2, 0, Math.PI*2); ctx.fill(); }
        requestAnimationFrame(draw);
    }

    function updatePhysics() {
        ball.vy += GRAVITY; ball.vx *= FRICTION; ball.vy *= FRICTION;
        let nextX = ball.x + ball.vx; let nextY = ball.y + ball.vy;
        if (nextX < BALL_RADIUS) { nextX = BALL_RADIUS; ball.vx *= -0.7; } if (nextX > width - BALL_RADIUS) { nextX = width - BALL_RADIUS; ball.vx *= -0.7; }
        for (let i=0; i<pins.length; i++) {
            const p = pins[i]; const dx = nextX - p.x; const dy = nextY - p.y; const distSq = dx*dx + dy*dy; const minDist = BALL_RADIUS + PIN_RADIUS;
            if (distSq < minDist * minDist) {
                pinHitIndex = i; const angle = Math.atan2(dy, dx);
                nextX = p.x + Math.cos(angle) * (minDist + 1.0); nextY = p.y + Math.sin(angle) * (minDist + 1.0);
                const noise = (Math.random() - 0.5) * 1.5; ball.vx += Math.cos(angle) * 1.5 + noise; ball.vy = Math.abs(ball.vy) * -BOUNCE; 
                if(Math.abs(ball.vx) < 0.3) ball.vx += (Math.random() > 0.5 ? 0.8 : -0.8);
            }
        }
        if (ball.y > 450 && ball.y < height - 50) {
            let bestTargetX = -1; let minDistance = 9999;
            const validIndices = mustWin ? activeSlotIndices : Array.from({length: NUM_SLOTS}, (_, i) => i).filter(i => !activeSlotIndices.includes(i));
            validIndices.forEach(idx => { const cx = slots[idx].cx; const dist = Math.abs(ball.x - cx); if (dist < minDistance) { minDistance = dist; bestTargetX = cx; targetSlotIndex = idx; } });
            if (bestTargetX !== -1) { const distToTarget = bestTargetX - ball.x; const strength = 0.005 + (ball.y / height) * 0.02; ball.vx += distToTarget * strength; }
        }
        ball.x = nextX; ball.y = nextY;
        if (ball.y > height - BALL_RADIUS) { ball.active = false; if(targetSlotIndex !== -1) ball.x = slots[targetSlotIndex].cx; ball.y = height - 25; setTimeout(showResult, 200); }
    }

    let provider, signer, contract, userAddress; let currentConfig = null; let pendingResult = null; let poolBalanceEth = 0;

    async function connectWallet() {
        if (!window.ethereum) return alert("Please install MetaMask");
        try {
            provider = new ethers.BrowserProvider(window.ethereum); signer = await provider.getSigner(); userAddress = await signer.getAddress();
            const network = await provider.getNetwork();
            if (network.chainId !== 25n) return alert("Please switch to Cronos Mainnet (Chain ID 25)");
            document.getElementById("connectBtn").style.display = "none"; document.getElementById("gameUI").style.display = "flex"; document.getElementById("walletAddr").innerText = userAddress.substring(0,6) + "...";
            contract = new ethers.Contract(CONTRACT_ADDRESS, ABI, signer); await updateData(); randomizeConfig(); initPhysics(); draw(); setInterval(updateData, 5000);
        } catch (e) { alert("Connect Failed"); }
    }

    async function updateData() {
        if(!contract || !userAddress) return;
        try {
            const bal = await contract.getBankrollBalance(); poolBalanceEth = parseFloat(ethers.formatEther(bal)); 
            document.getElementById("poolAmount").innerText = poolBalanceEth.toFixed(2);
            const userBal = await provider.getBalance(userAddress); document.getElementById("userBalance").innerText = parseFloat(ethers.formatEther(userBal)).toFixed(2);
            validateBet();
        } catch(e){}
    }

    function randomizeConfig() {
        const conf = CONFIGS[Math.floor(Math.random() * CONFIGS.length)]; currentConfig = conf;
        document.getElementById("disp-multi").innerText = conf.multi + "X";
        let all = Array.from({length: NUM_SLOTS}, (_, i) => i); activeSlotIndices = all.sort(() => 0.5 - Math.random()).slice(0, conf.lights);
        validateBet();
    }

    function validateBet() {
        if (!currentConfig) return;
        let maxBet = (poolBalanceEth / 4) / currentConfig.multi;
        document.getElementById("maxBetVal").innerText = maxBet.toFixed(2);
        const input = document.getElementById("betAmount"); const amt = parseFloat(input.value); const btn = document.getElementById("playBtn"); const wrapper = document.getElementById("betWrapper");
        if(amt > 0 && amt <= maxBet) { btn.disabled = false; wrapper.classList.remove("error"); } else { btn.disabled = true; wrapper.classList.add("error"); }
    }

    async function playGame() {
        if (!currentConfig) return;
        const amt = document.getElementById("betAmount").value; const playBtn = document.getElementById("playBtn");
        playBtn.disabled = true; playBtn.innerHTML = getTrans("waiting");
        try {
            const tx = await contract.play(currentConfig.multi, { value: ethers.parseEther(amt) });
            playBtn.innerHTML = getTrans("rolling");
            const receipt = await tx.wait();
            let wonMultiplier = 0; let payout = 0;
            for (const log of receipt.logs) { try { const parsed = contract.interface.parseLog(log); if (parsed.name === "BallShot" && parsed.args.player === userAddress) { wonMultiplier = Number(parsed.args.multiplier); payout = ethers.formatEther(parsed.args.payout); } } catch(e){} }
            startBallDrop(wonMultiplier, payout); updateData(); 
        } catch (e) { console.error(e); alert("Transaction Cancelled"); resetUI(); }
    }

    function startBallDrop(multiplier, payout) {
        pendingResult = { payout, win: multiplier > 0 }; mustWin = multiplier > 0;
        ball.x = width / 2 + (Math.random()-0.5) * 60; ball.y = 20; ball.vx = (Math.random() - 0.5) * 3; ball.vy = 0; ball.active = true;
    }

    function showResult() {
        const modal = document.getElementById("resultModal"); const title = document.getElementById("resTitle"); const val = document.getElementById("resVal");
        modal.style.display = "flex";
        if (pendingResult.win) { title.innerText = getTrans("win"); title.style.color = "#00f2ff"; val.innerText = "+" + pendingResult.payout + " CRO"; } 
        else { title.innerText = getTrans("lose"); title.style.color = "#888"; val.innerText = "Try Again"; }
        updateData();
    }

    function resetUI() { const btn = document.getElementById("playBtn"); btn.disabled = false; btn.innerHTML = `<span data-i18n="play_btn">${getTrans("play_btn")}</span>`; }
    function openRules() { document.getElementById("rulesModal").style.display = "flex"; updateText(); }
    function closeModal(id) { document.getElementById(id).style.display = "none"; if(id === "resultModal") resetUI(); }
    function toggleLang() { curLang = curLang === 'zh' ? 'en' : 'zh'; updateText(); }
    function getTrans(key) { return i18n[curLang][key]; }
    function updateText() { document.querySelectorAll('[data-i18n]').forEach(el => { el.innerText = i18n[curLang][el.getAttribute('data-i18n')]; }); document.getElementById("rulesContent").innerHTML = i18n[curLang]['rule_html']; }

    updateText(); initPhysics(); draw(); 
</script>
</body>
</html>
